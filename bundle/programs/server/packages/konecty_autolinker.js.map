{"version":3,"sources":["meteor://ðŸ’»app/packages/konecty_autolinker/autolinker.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8H","file":"/packages/konecty_autolinker.js","sourcesContent":["\n\t/*!\n\t * Autolinker.js\n\t * 0.15.2\n\t *\n\t * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>\n\t * MIT Licensed. http://www.opensource.org/licenses/mit-license.php\n\t *\n\t * https://github.com/gregjacobs/Autolinker.js\n\t */\n\t/**\n\t * @class Autolinker\n\t * @extends Object\n\t *\n\t * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in\n\t * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n\t *\n\t * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which\n\t * will configure how the {@link #link link()} method will process the links.\n\t *\n\t * For example:\n\t *\n\t *     var autolinker = new Autolinker( {\n\t *         newWindow : false,\n\t *         truncate  : 30\n\t *     } );\n\t *\n\t *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n\t *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n\t *\n\t *\n\t * The {@link #static-link static link()} method may also be used to inline options into a single call, which may\n\t * be more convenient for one-off uses. For example:\n\t *\n\t *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n\t *         newWindow : false,\n\t *         truncate  : 30\n\t *     } );\n\t *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n\t *\n\t *\n\t * ## Custom Replacements of Links\n\t *\n\t * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize\n\t * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.\n\t *\n\t * For example:\n\t *\n\t *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n\t *\n\t *     var linkedText = Autolinker.link( input, {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             console.log( \"href = \", match.getAnchorHref() );\n\t *             console.log( \"text = \", match.getAnchorText() );\n\t *\n\t *             switch( match.getType() ) {\n\t *                 case 'url' :\n\t *                     console.log( \"url: \", match.getUrl() );\n\t *\n\t *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n\t *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n\t *                         tag.setAttr( 'rel', 'nofollow' );\n\t *                         tag.addClass( 'external-link' );\n\t *\n\t *                         return tag;\n\t *\n\t *                     } else {\n\t *                         return true;  // let Autolinker perform its normal anchor tag replacement\n\t *                     }\n\t *\n\t *                 case 'email' :\n\t *                     var email = match.getEmail();\n\t *                     console.log( \"email: \", email );\n\t *\n\t *                     if( email === \"my@own.address\" ) {\n\t *                         return false;  // don't auto-link this particular email address; leave as-is\n\t *                     } else {\n\t *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n\t *                     }\n\t *\n\t *                 case 'twitter' :\n\t *                     var twitterHandle = match.getTwitterHandle();\n\t *                     console.log( twitterHandle );\n\t *\n\t *                     return '<a href=\"http://newplace.to.link.twitter.handles.to/\">' + twitterHandle + '</a>';\n\t *             }\n\t *         }\n\t *     } );\n\t *\n\t *\n\t * The function may return the following values:\n\t *\n\t * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.\n\t * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n\t * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for\n\t *   the match.\n\t * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.\n\t *\n\t * @constructor\n\t * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).\n\t */\n\tAutolinker = function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.\n\n\t\tthis.matchValidator = new Autolinker.MatchValidator();\n\t};\n\n\n\tAutolinker.prototype = {\n\t\tconstructor : Autolinker,  // fix constructor property\n\n\t\t/**\n\t\t * @cfg {Boolean} urls\n\t\t *\n\t\t * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n\t\t */\n\t\turls : true,\n\n\t\t/**\n\t\t * @cfg {Boolean} email\n\t\t *\n\t\t * `true` if email addresses should be automatically linked, `false` if they should not be.\n\t\t */\n\t\temail : true,\n\n\t\t/**\n\t\t * @cfg {Boolean} twitter\n\t\t *\n\t\t * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n\t\t */\n\t\ttwitter : true,\n\n\t\t/**\n\t\t * @cfg {Boolean} newWindow\n\t\t *\n\t\t * `true` if the links should open in a new window, `false` otherwise.\n\t\t */\n\t\tnewWindow : true,\n\n\t\t/**\n\t\t * @cfg {Boolean} stripPrefix\n\t\t *\n\t\t * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text,\n\t\t * `false` otherwise.\n\t\t */\n\t\tstripPrefix : true,\n\n\t\t/**\n\t\t * @cfg {Number} truncate\n\t\t *\n\t\t * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of\n\t\t * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by\n\t\t * adding a two period ellipsis ('..') to the end of the string.\n\t\t *\n\t\t * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look\n\t\t * something like this: 'yahoo.com/some/long/pat..'\n\t\t */\n\n\t\t/**\n\t\t * @cfg {String} className\n\t\t *\n\t\t * A CSS class name to add to the generated links. This class will be added to all links, as well as this class\n\t\t * plus url/email/twitter suffixes for styling url/email/twitter links differently.\n\t\t *\n\t\t * For example, if this config is provided as \"myLink\", then:\n\t\t *\n\t\t * - URL links will have the CSS classes: \"myLink myLink-url\"\n\t\t * - Email links will have the CSS classes: \"myLink myLink-email\", and\n\t\t * - Twitter links will have the CSS classes: \"myLink myLink-twitter\"\n\t\t */\n\t\tclassName : \"\",\n\n\t\t/**\n\t\t * @cfg {Function} replaceFn\n\t\t *\n\t\t * A function to individually process each URL/Email/Twitter match found in the input string.\n\t\t *\n\t\t * See the class's description for usage.\n\t\t *\n\t\t * This function is called with the following parameters:\n\t\t *\n\t\t * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such\n\t\t *   as the instance's {@link #getTagBuilder tag builder}).\n\t\t * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the\n\t\t *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}\n\t\t *   match that the `replaceFn` is currently processing.\n\t\t */\n\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} htmlCharacterEntitiesRegex\n\t\t *\n\t\t * The regular expression that matches common HTML character entities.\n\t\t *\n\t\t * Ignoring &amp; as it could be part of a query string -- handling it separately.\n\t\t */\n\t\thtmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} matcherRegex\n\t\t *\n\t\t * The regular expression that matches URLs, email addresses, and Twitter handles.\n\t\t *\n\t\t * This regular expression has the following capturing groups:\n\t\t *\n\t\t * 1. Group that is used to determine if there is a Twitter handle match (i.e. \\@someTwitterUser). Simply check for its\n\t\t *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information\n\t\t *    about the Twitter handle match.\n\t\t * 2. The whitespace character before the \\@sign in a Twitter handle. This is needed because there are no lookbehinds in\n\t\t *    JS regular expressions, and can be used to reconstruct the original string in a replace().\n\t\t * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.\n\t\t * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full\n\t\t *    address. Ex: 'me@my.com'\n\t\t * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.\n\t\t *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor\n\t\t * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single\n\t\t *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n\t\t * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a\n\t\t *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match\n\t\t *    or the // was in a string we don't want to auto-link.\n\t\t * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a\n\t\t *    protocol-relative match. See #6 for more info.\n\t\t */\n\t\tmatcherRegex : (function() {\n\t\t\tvar twitterRegex = /(^|[^\\w])@(\\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs\n\n\t\t\t    emailRegex = /(?:[\\-;:&=\\+\\$,\\w\\.]+@)/,             // something@ for email addresses (a.k.a. local-part)\n\n\t\t\t    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/,  // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n\t\t\t    wwwRegex = /(?:www\\.)/,                             // starting with 'www.'\n\t\t\t    domainNameRegex = /[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period\n\t\t\t    tldRegex = /\\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\\b/,   // match our known top level domains (TLDs)\n\n\t\t\t    phoneRegex = /((?:\\([0-9]{1,3}\\)|[0-9]{2})[ \\-]*?[0-9]{4,5}(?:[\\-\\s\\_]{1,2})?[0-9]{4}(?:(?=[^0-9])|$)|[0-9]{4,5}(?:[\\-\\s\\_]{1,2})?[0-9]{4}(?:(?=[^0-9])|$))/,\n\n\t\t\t    // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n\t\t\t    // http://blog.codinghorror.com/the-problem-with-urls/\n\t\t\t    urlSuffixRegex = /[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]?!:,.;]*[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]]/;\n\n\t\t\treturn new RegExp( [\n\t\t\t\t'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()\n\t\t\t\t\t// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and\n\t\t\t\t\t// *** Capturing group $3, which matches the actual twitter handle\n\t\t\t\t\ttwitterRegex.source,\n\t\t\t\t')',\n\n\t\t\t\t'|',\n\n\t\t\t\t'(',  // *** Capturing group $4, which is used to determine an email match\n\t\t\t\t\temailRegex.source,\n\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\ttldRegex.source,\n\t\t\t\t')',\n\n\t\t\t\t'|',\n\n\t\t\t\t'(',  // *** Capturing group $5, which is used to match a URL\n\t\t\t\t\t'(?:', // parens to cover match for protocol (optional), and domain\n\t\t\t\t\t\t'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)\n\t\t\t\t\t\t\tprotocolRegex.source,\n\t\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t\t')',\n\n\t\t\t\t\t\t'|',\n\n\t\t\t\t\t\t'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)\n\t\t\t\t\t\t\t'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n\t\t\t\t\t\t\twwwRegex.source,\n\t\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t\t')',\n\n\t\t\t\t\t\t'|',\n\n\t\t\t\t\t\t'(?:',  // non-capturing paren for known a TLD url (ex: google.com)\n\t\t\t\t\t\t\t'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n\t\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t\t\ttldRegex.source,\n\t\t\t\t\t\t')',\n\t\t\t\t\t')',\n\n\t\t\t\t\t'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional\n\t\t\t\t')',\n\n\t\t\t\t'|',\n\n\t\t\t\t'(', phoneRegex.source, ')'\n\n\t\t\t].join( \"\" ), 'gi' );\n\t\t} )(),\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} charBeforeProtocolRelMatchRegex\n\t\t *\n\t\t * The regular expression used to retrieve the character before a protocol-relative URL match.\n\t\t *\n\t\t * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative\n\t\t * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped\n\t\t * from the URL.\n\t\t */\n\t\tcharBeforeProtocolRelMatchRegex : /^(.)?\\/\\//,\n\n\t\t/**\n\t\t * @private\n\t\t * @property {Autolinker.MatchValidator} matchValidator\n\t\t *\n\t\t * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See\n\t\t * {@link Autolinker.MatchValidator} for details.\n\t\t */\n\n\t\t/**\n\t\t * @private\n\t\t * @property {Autolinker.HtmlParser} htmlParser\n\t\t *\n\t\t * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated\n\t\t * in the {@link #getHtmlParser} method.\n\t\t */\n\n\t\t/**\n\t\t * @private\n\t\t * @property {Autolinker.AnchorTagBuilder} tagBuilder\n\t\t *\n\t\t * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated\n\t\t * in the {@link #getTagBuilder} method.\n\t\t */\n\n\n\t\t/**\n\t\t * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML.\n\t\t * Does not link URLs found within HTML tags.\n\t\t *\n\t\t * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result\n\t\t * will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n\t\t *\n\t\t * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.\n\t\t * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.\n\t\t *\n\t\t * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if\n\t\t *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).\n\t\t * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.\n\t\t */\n\t\tlink : function( textOrHtml ) {\n\t\t\tvar me = this,  // for closure\n\t\t\t    htmlParser = this.getHtmlParser(),\n\t\t\t    htmlCharacterEntitiesRegex = this.htmlCharacterEntitiesRegex,\n\t\t\t    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have\n\t\t\t    resultHtml = [];\n\n\t\t\thtmlParser.parse( textOrHtml, {\n\t\t\t\t// Process HTML nodes in the input `textOrHtml`\n\t\t\t\tprocessHtmlNode : function( tagText, tagName, isClosingTag ) {\n\t\t\t\t\tif( tagName === 'a' ) {\n\t\t\t\t\t\tif( !isClosingTag ) {  // it's the start <a> tag\n\t\t\t\t\t\t\tanchorTagStackCount++;\n\t\t\t\t\t\t} else {   // it's the end </a> tag\n\t\t\t\t\t\t\tanchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresultHtml.push( tagText );  // now add the text of the tag itself verbatim\n\t\t\t\t},\n\n\t\t\t\t// Process text nodes in the input `textOrHtml`\n\t\t\t\tprocessTextNode : function( text ) {\n\t\t\t\t\tif( anchorTagStackCount === 0 ) {\n\t\t\t\t\t\t// If we're not within an <a> tag, process the text node\n\t\t\t\t\t\tvar unescapedText = Autolinker.Util.splitAndCapture( text, htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array\n\n\t\t\t\t\t\tfor ( var i = 0, len = unescapedText.length; i < len; i++ ) {\n\t\t\t\t\t\t\tvar textToProcess = unescapedText[ i ],\n\t\t\t\t\t\t\t    processedTextNode = me.processTextNode( textToProcess );\n\n\t\t\t\t\t\t\tresultHtml.push( processedTextNode );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// `text` is within an <a> tag, simply append the text - we do not want to autolink anything\n\t\t\t\t\t\t// already within an <a>...</a> tag\n\t\t\t\t\t\tresultHtml.push( text );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn resultHtml.join( \"\" );\n\t\t},\n\n\n\t\t/**\n\t\t * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.\n\t\t *\n\t\t * @protected\n\t\t * @return {Autolinker.HtmlParser}\n\t\t */\n\t\tgetHtmlParser : function() {\n\t\t\tvar htmlParser = this.htmlParser;\n\n\t\t\tif( !htmlParser ) {\n\t\t\t\thtmlParser = this.htmlParser = new Autolinker.HtmlParser();\n\t\t\t}\n\n\t\t\treturn htmlParser;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n\t\t * if it does not yet exist.\n\t\t *\n\t\t * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n\t\t * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n\t\t *\n\t\t *     var html = Autolinker.link( \"Test google.com\", {\n\t\t *         replaceFn : function( autolinker, match ) {\n\t\t *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n\t\t *             tag.setAttr( 'rel', 'nofollow' );\n\t\t *\n\t\t *             return tag;\n\t\t *         }\n\t\t *     } );\n\t\t *\n\t\t *     // generated html:\n\t\t *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n\t\t *\n\t\t * @return {Autolinker.AnchorTagBuilder}\n\t\t */\n\t\tgetTagBuilder : function() {\n\t\t\tvar tagBuilder = this.tagBuilder;\n\n\t\t\tif( !tagBuilder ) {\n\t\t\t\ttagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {\n\t\t\t\t\tnewWindow   : this.newWindow,\n\t\t\t\t\ttruncate    : this.truncate,\n\t\t\t\t\tclassName   : this.className\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn tagBuilder;\n\t\t},\n\n\n\t\t/**\n\t\t * Process the text that lies inbetween HTML tags. This method does the actual wrapping of URLs with\n\t\t * anchor tags.\n\t\t *\n\t\t * @private\n\t\t * @param {String} text The text to auto-link.\n\t\t * @return {String} The text with anchor tags auto-filled.\n\t\t */\n\t\tprocessTextNode : function( text ) {\n\t\t\tvar me = this;  // for closure\n\n\t\t\treturn text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9 ) {\n\t\t\t\tvar matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9 );  // match description object\n\n\t\t\t\t// Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are\n\t\t\t\t// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).\n\t\t\t\tif( !matchDescObj ) {\n\t\t\t\t\treturn matchStr;\n\n\t\t\t\t} else {\n\t\t\t\t\t// Generate the replacement text for the match\n\t\t\t\t\tvar matchReturnVal = me.createMatchReturnVal( matchDescObj.match, matchDescObj.matchStr );\n\t\t\t\t\treturn matchDescObj.prefixStr + matchReturnVal + matchDescObj.suffixStr;\n\t\t\t\t}\n\t\t\t} );\n\t\t},\n\n\n\t\t/**\n\t\t * Processes a candidate match from the {@link #matcherRegex}.\n\t\t *\n\t\t * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In\n\t\t * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.\n\t\t *\n\t\t * @private\n\t\t * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.\n\t\t * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.\n\t\t * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This\n\t\t *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.\n\t\t * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).\n\t\t * @param {String} emailAddressMatch The matched email address for an email address match.\n\t\t * @param {String} urlMatch The matched URL string for a URL match.\n\t\t * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n\t\t *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n\t\t * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that\n\t\t *   comes before the '//'.\n\t\t * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with\n\t\t *   the character that comes before the '//'.\n\t\t *\n\t\t * @return {Object} A \"match description object\". This will be `null` if the match was invalid, or if a match type is disabled.\n\t\t *   Otherwise, this will be an Object (map) with the following properties:\n\t\t * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that\n\t\t *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into\n\t\t *   the replacement stream.\n\t\t * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that\n\t\t *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into\n\t\t *   the replacement stream.\n\t\t * @return {String} return.matchStr The `matchStr`, fixed up to remove characters that are no longer needed (which have been\n\t\t *   added to `prefixStr` and `suffixStr`).\n\t\t * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.\n\t\t */\n\t\tprocessCandidateMatch : function(\n\t\t\tmatchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle,\n\t\t\temailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch, phoneMatch\n\t\t) {\n\t\t\tvar protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,\n\t\t\t    match,  // Will be an Autolinker.match.Match object\n\n\t\t\t    prefixStr = \"\",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match\n\t\t\t    suffixStr = \"\";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.\n\n\n\t\t\t// Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are\n\t\t\t// invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).\n\t\t\tif(\n\t\t\t\t( twitterMatch && !this.twitter ) || ( emailAddressMatch && !this.email ) || ( urlMatch && !this.urls ) ||\n\t\t\t\t!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch )\n\t\t\t) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis\n\t\t\t// in the match itself.\n\t\t\tif( this.matchHasUnbalancedClosingParen( matchStr ) ) {\n\t\t\t\tmatchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing \")\"\n\t\t\t\tsuffixStr = \")\";  // this will be added after the generated <a> tag\n\t\t\t}\n\n\n\t\t\tif( emailAddressMatch ) {\n\t\t\t\tmatch = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );\n\n\t\t\t} else if( twitterMatch ) {\n\t\t\t\t// fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match\n\t\t\t\t// itself (since there are no look-behinds in JS regexes)\n\t\t\t\tif( twitterHandlePrefixWhitespaceChar ) {\n\t\t\t\t\tprefixStr = twitterHandlePrefixWhitespaceChar;\n\t\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match\n\t\t\t\t}\n\t\t\t\tmatch = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );\n\n\t\t\t} else if (phoneMatch) {\n\n\t\t\t\tmatch = new Autolinker.match.Phone( { matchedText: matchStr, phone: phoneMatch } );\n\t\t\t} else {  // url match\n\t\t\t\t// If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed\n\t\t\t\t// to match due to the lack of a negative look-behind in JavaScript regular expressions)\n\t\t\t\tif( protocolRelativeMatch ) {\n\t\t\t\t\tvar charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || \"\";\n\n\t\t\t\t\tif( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)\n\t\t\t\t\t\tprefixStr = charBeforeMatch;\n\t\t\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed char from the match\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmatch = new Autolinker.match.Url( {\n\t\t\t\t\tmatchedText : matchStr,\n\t\t\t\t\turl : matchStr,\n\t\t\t\t\tprotocolUrlMatch : !!protocolUrlMatch,\n\t\t\t\t\tprotocolRelativeMatch : !!protocolRelativeMatch,\n\t\t\t\t\tstripPrefix : this.stripPrefix\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tprefixStr : prefixStr,\n\t\t\t\tsuffixStr : suffixStr,\n\t\t\t\tmatchStr  : matchStr,\n\t\t\t\tmatch     : match\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed\n\t\t * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.\n\t\t *\n\t\t * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis\n\t\t * for URLs such as \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n\t\t *\n\t\t * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of\n\t\t * \"(wikipedia.com/something_(disambiguation))\". In this case, the last closing parenthesis should *not* be part of the URL\n\t\t * itself, and this method will return `true`.\n\t\t *\n\t\t * @private\n\t\t * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n\t\t * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.\n\t\t */\n\t\tmatchHasUnbalancedClosingParen : function( matchStr ) {\n\t\t\tvar lastChar = matchStr.charAt( matchStr.length - 1 );\n\n\t\t\tif( lastChar === ')' ) {\n\t\t\t\tvar openParensMatch = matchStr.match( /\\(/g ),\n\t\t\t\t    closeParensMatch = matchStr.match( /\\)/g ),\n\t\t\t\t    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,\n\t\t\t\t    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;\n\n\t\t\t\tif( numOpenParens < numCloseParens ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.\n\t\t *\n\t\t * This method handles the {@link #replaceFn}, if one was provided.\n\t\t *\n\t\t * @private\n\t\t * @param {Autolinker.match.Match} match The Match object that represents the match.\n\t\t * @param {String} matchStr The original match string, after having been preprocessed to fix match edge cases (see\n\t\t *   the `prefixStr` and `suffixStr` vars in {@link #processTextNode}.\n\t\t * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but\n\t\t *   may be the `matchStr` itself if the match is not to be replaced.\n\t\t */\n\t\tcreateMatchReturnVal : function( match, matchStr ) {\n\t\t\t// Handle a custom `replaceFn` being provided\n\t\t\tvar replaceFnResult;\n\t\t\tif( this.replaceFn ) {\n\t\t\t\treplaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg\n\t\t\t}\n\n\t\t\tif( typeof replaceFnResult === 'string' ) {\n\t\t\t\treturn replaceFnResult;  // `replaceFn` returned a string, use that\n\n\t\t\t} else if( replaceFnResult === false ) {\n\t\t\t\treturn matchStr;  // no replacement for the match\n\n\t\t\t} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {\n\t\t\t\treturn replaceFnResult.toString();\n\n\t\t\t} else {  // replaceFnResult === true, or no/unknown return value from function\n\t\t\t\t// Perform Autolinker's default anchor tag generation\n\t\t\t\tvar tagBuilder = this.getTagBuilder(),\n\t\t\t\t    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance\n\n\t\t\t\treturn anchorTag.toString();\n\t\t\t}\n\t\t}\n\n\t};\n\n\n\t/**\n\t * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML.\n\t * Does not link URLs found within HTML tags.\n\t *\n\t * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result\n\t * will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n\t *\n\t * Example:\n\t *\n\t *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n\t *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n\t *\n\t * @static\n\t * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if\n\t *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).\n\t * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).\n\t *   See the class description for an example call.\n\t * @return {String} The HTML text, with URLs automatically linked\n\t */\n\tAutolinker.link = function( textOrHtml, options ) {\n\t\tvar autolinker = new Autolinker( options );\n\t\treturn autolinker.link( textOrHtml );\n\t};\n\n\n\t// Namespace for `match` classes\n\tAutolinker.match = {};\n\t/*global Autolinker */\n\t/*jshint eqnull:true, boss:true */\n\t/**\n\t * @class Autolinker.Util\n\t * @singleton\n\t *\n\t * A few utility methods for Autolinker.\n\t */\n\tAutolinker.Util = {\n\n\t\t/**\n\t\t * @property {Function} abstractMethod\n\t\t *\n\t\t * A function object which represents an abstract method.\n\t\t */\n\t\tabstractMethod : function() { throw \"abstract\"; },\n\n\n\t\t/**\n\t\t * Assigns (shallow copies) the properties of `src` onto `dest`.\n\t\t *\n\t\t * @param {Object} dest The destination object.\n\t\t * @param {Object} src The source object.\n\t\t * @return {Object} The destination object (`dest`)\n\t\t */\n\t\tassign : function( dest, src ) {\n\t\t\tfor( var prop in src ) {\n\t\t\t\tif( src.hasOwnProperty( prop ) ) {\n\t\t\t\t\tdest[ prop ] = src[ prop ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest;\n\t\t},\n\n\n\t\t/**\n\t\t * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.\n\t\t *\n\t\t * @param {Function} superclass The constructor function for the superclass.\n\t\t * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the\n\t\t *   special property `constructor`, which will be used as the new subclass's constructor function.\n\t\t * @return {Function} The new subclass function.\n\t\t */\n\t\textend : function( superclass, protoProps ) {\n\t\t\tvar superclassProto = superclass.prototype;\n\n\t\t\tvar F = function() {};\n\t\t\tF.prototype = superclassProto;\n\n\t\t\tvar subclass;\n\t\t\tif( protoProps.hasOwnProperty( 'constructor' ) ) {\n\t\t\t\tsubclass = protoProps.constructor;\n\t\t\t} else {\n\t\t\t\tsubclass = function() { superclassProto.constructor.apply( this, arguments ); };\n\t\t\t}\n\n\t\t\tvar subclassProto = subclass.prototype = new F();  // set up prototype chain\n\t\t\tsubclassProto.constructor = subclass;  // fix constructor property\n\t\t\tsubclassProto.superclass = superclassProto;\n\n\t\t\tdelete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there\n\t\t\tAutolinker.Util.assign( subclassProto, protoProps );\n\n\t\t\treturn subclass;\n\t\t},\n\n\n\t\t/**\n\t\t * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n\t\t * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n\t\t * `len`, the string will be returned unchanged.\n\t\t *\n\t\t * @param {String} str The string to truncate and add an ellipsis to.\n\t\t * @param {Number} truncateLen The length to truncate the string at.\n\t\t * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`\n\t\t *   when truncated. Defaults to '..'\n\t\t */\n\t\tellipsis : function( str, truncateLen, ellipsisChars ) {\n\t\t\tif( str.length > truncateLen ) {\n\t\t\t\tellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;\n\t\t\t\tstr = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;\n\t\t\t}\n\t\t\treturn str;\n\t\t},\n\n\n\t\t/**\n\t\t * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n\t\t *\n\t\t * @param {Array} arr The array to find an element of.\n\t\t * @param {*} element The element to find in the array, and return the index of.\n\t\t * @return {Number} The index of the `element`, or -1 if it was not found.\n\t\t */\n\t\tindexOf : function( arr, element ) {\n\t\t\tif( Array.prototype.indexOf ) {\n\t\t\t\treturn arr.indexOf( element );\n\n\t\t\t} else {\n\t\t\t\tfor( var i = 0, len = arr.length; i < len; i++ ) {\n\t\t\t\t\tif( arr[ i ] === element ) return i;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n\t\t * with a regular expression that contains capturing parenthesis.\n\t\t *\n\t\t * For example:\n\t\t *\n\t\t *     // Modern browsers:\n\t\t *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n\t\t *\n\t\t *     // Old IE (including IE8):\n\t\t *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n\t\t *\n\t\t * This method emulates the functionality of modern browsers for the old IE case.\n\t\t *\n\t\t * @param {String} str The string to split.\n\t\t * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n\t\t *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n\t\t *   description of this method.\n\t\t *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n\t\t *   Note #2: for simplicity's sake, the regular expression does not need\n\t\t *   to contain capturing parenthesis - it will be assumed that any match has them.\n\t\t * @return {String[]} The split array of strings, with the splitting character(s) included.\n\t\t */\n\t\tsplitAndCapture : function( str, splitRegex ) {\n\t\t\tif( !splitRegex.global ) throw new Error( \"`splitRegex` must have the 'g' flag set\" );\n\n\t\t\tvar result = [],\n\t\t\t    lastIdx = 0,\n\t\t\t    match;\n\n\t\t\twhile( match = splitRegex.exec( str ) ) {\n\t\t\t\tresult.push( str.substring( lastIdx, match.index ) );\n\t\t\t\tresult.push( match[ 0 ] );  // push the splitting char(s)\n\n\t\t\t\tlastIdx = match.index + match[ 0 ].length;\n\t\t\t}\n\t\t\tresult.push( str.substring( lastIdx ) );\n\n\t\t\treturn result;\n\t\t}\n\n\t};\n\t/*global Autolinker */\n\t/**\n\t * @private\n\t * @class Autolinker.HtmlParser\n\t * @extends Object\n\t *\n\t * An HTML parser implementation which simply walks an HTML string and calls the provided visitor functions to process\n\t * HTML and text nodes.\n\t *\n\t * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, basically ignoring HTML tags.\n\t */\n\tAutolinker.HtmlParser = Autolinker.Util.extend( Object, {\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} htmlRegex\n\t\t *\n\t\t * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n\t\t * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n\t\t *\n\t\t * Capturing groups:\n\t\t *\n\t\t * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n\t\t * 2. If it is an end tag, this group will have the '/'.\n\t\t * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)\n\t\t */\n\t\thtmlRegex : (function() {\n\t\t\tvar tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n\t\t\t    attrNameRegex = /[^\\s\\0\"'>\\/=\\x01-\\x1F\\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char\n\t\t\t    attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n\t\t\t    nameEqualsValueRegex = attrNameRegex.source + '(?:\\\\s*=\\\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'\n\n\t\t\treturn new RegExp( [\n\t\t\t\t// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t\t'(?:',\n\t\t\t\t\t'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag\n\n\t\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t\t'\\\\s+',  // one or more whitespace chars before an attribute\n\n\t\t\t\t\t\t\t// Either:\n\t\t\t\t\t\t\t// A. attr=\"value\", or\n\t\t\t\t\t\t\t// B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t\t\t\t\t'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',\n\t\t\t\t\t\t')*',\n\t\t\t\t\t'>',\n\t\t\t\t')',\n\n\t\t\t\t'|',\n\n\t\t\t\t// All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n\t\t\t\t'(?:',\n\t\t\t\t\t'<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag.\n\t\t\t\t\t          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n\n\t\t\t\t\t\t// *** Capturing Group 3 - The tag name\n\t\t\t\t\t\t'(' + tagNameRegex.source + ')',\n\n\t\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t\t'\\\\s+',                // one or more whitespace chars before an attribute\n\t\t\t\t\t\t\tnameEqualsValueRegex,  // attr=\"value\" (with optional =\"value\" part)\n\t\t\t\t\t\t')*',\n\n\t\t\t\t\t\t'\\\\s*/?',  // any trailing spaces and optional '/' before the closing '>'\n\t\t\t\t\t'>',\n\t\t\t\t')'\n\t\t\t].join( \"\" ), 'gi' );\n\t\t} )(),\n\n\n\t\t/**\n\t\t * Walks an HTML string, calling the `options.processHtmlNode` function for each HTML tag that is encountered, and calling\n\t\t * the `options.processTextNode` function when each text around HTML tags is encountered.\n\t\t *\n\t\t * @param {String} html The HTML to parse.\n\t\t * @param {Object} [options] An Object (map) which may contain the following properties:\n\t\t *\n\t\t * @param {Function} [options.processHtmlNode] A visitor function which allows processing of an encountered HTML node.\n\t\t *   This function is called with the following arguments:\n\t\t * @param {String} [options.processHtmlNode.tagText] The HTML tag text that was found.\n\t\t * @param {String} [options.processHtmlNode.tagName] The tag name for the HTML tag that was found. Ex: 'a' for an anchor tag.\n\t\t * @param {String} [options.processHtmlNode.isClosingTag] `true` if the tag is a closing tag (ex: &lt;/a&gt;), `false` otherwise.\n\t\t *\n\t\t * @param {Function} [options.processTextNode] A visitor function which allows processing of an encountered text node.\n\t\t *   This function is called with the following arguments:\n\t\t * @param {String} [options.processTextNode.text] The text node that was matched.\n\t\t */\n\t\tparse : function( html, options ) {\n\t\t\toptions = options || {};\n\n\t\t\tvar processHtmlNodeVisitor = options.processHtmlNode || function() {},\n\t\t\t    processTextNodeVisitor = options.processTextNode || function() {},\n\t\t\t    htmlRegex = this.htmlRegex,\n\t\t\t    currentResult,\n\t\t\t    lastIndex = 0;\n\n\t\t\t// Loop over the HTML string, ignoring HTML tags, and processing the text that lies between them,\n\t\t\t// wrapping the URLs in anchor tags\n\t\t\twhile( ( currentResult = htmlRegex.exec( html ) ) !== null ) {\n\t\t\t\tvar tagText = currentResult[ 0 ],\n\t\t\t\t    tagName = currentResult[ 1 ] || currentResult[ 3 ],  // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\")\n\t\t\t\t    isClosingTag = !!currentResult[ 2 ],\n\t\t\t\t    inBetweenTagsText = html.substring( lastIndex, currentResult.index );\n\n\t\t\t\tif( inBetweenTagsText ) {\n\t\t\t\t\tprocessTextNodeVisitor( inBetweenTagsText );\n\t\t\t\t}\n\n\t\t\t\tprocessHtmlNodeVisitor( tagText, tagName.toLowerCase(), isClosingTag );\n\n\t\t\t\tlastIndex = currentResult.index + tagText.length;\n\t\t\t}\n\n\t\t\t// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n\t\t\tif( lastIndex < html.length ) {\n\t\t\t\tvar text = html.substring( lastIndex );\n\n\t\t\t\tif( text ) {\n\t\t\t\t\tprocessTextNodeVisitor( text );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/*jshint boss:true */\n\t/**\n\t * @class Autolinker.HtmlTag\n\t * @extends Object\n\t *\n\t * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n\t *\n\t * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n\t * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n\t *\n\t * ## Examples\n\t *\n\t * Example instantiation:\n\t *\n\t *     var tag = new Autolinker.HtmlTag( {\n\t *         tagName : 'a',\n\t *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n\t *         innerHtml : 'Google'\n\t *     } );\n\t *\n\t *     tag.toString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n\t *\n\t *     // Individual accessor methods\n\t *     tag.getTagName();                 // 'a'\n\t *     tag.getAttr( 'href' );            // 'http://google.com'\n\t *     tag.hasClass( 'external-link' );  // true\n\t *\n\t *\n\t * Using mutator methods (which may be used in combination with instantiation config properties):\n\t *\n\t *     var tag = new Autolinker.HtmlTag();\n\t *     tag.setTagName( 'a' );\n\t *     tag.setAttr( 'href', 'http://google.com' );\n\t *     tag.addClass( 'external-link' );\n\t *     tag.setInnerHtml( 'Google' );\n\t *\n\t *     tag.getTagName();                 // 'a'\n\t *     tag.getAttr( 'href' );            // 'http://google.com'\n\t *     tag.hasClass( 'external-link' );  // true\n\t *\n\t *     tag.toString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n\t *\n\t *\n\t * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n\t *\n\t *     var html = Autolinker.link( \"Test google.com\", {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n\t *             tag.setAttr( 'rel', 'nofollow' );\n\t *\n\t *             return tag;\n\t *         }\n\t *     } );\n\t *\n\t *     // generated html:\n\t *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n\t *\n\t *\n\t * ## Example use with a new tag for the replacement\n\t *\n\t *     var html = Autolinker.link( \"Test google.com\", {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             var tag = new Autolinker.HtmlTag( {\n\t *                 tagName : 'button',\n\t *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n\t *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n\t *             } );\n\t *\n\t *             return tag;\n\t *         }\n\t *     } );\n\t *\n\t *     // generated html:\n\t *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n\t */\n\tAutolinker.HtmlTag = Autolinker.Util.extend( Object, {\n\n\t\t/**\n\t\t * @cfg {String} tagName\n\t\t *\n\t\t * The tag name. Ex: 'a', 'button', etc.\n\t\t *\n\t\t * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}\n\t\t * is executed.\n\t\t */\n\n\t\t/**\n\t\t * @cfg {Object.<String, String>} attrs\n\t\t *\n\t\t * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the\n\t\t * values are the attribute values.\n\t\t */\n\n\t\t/**\n\t\t * @cfg {String} innerHtml\n\t\t *\n\t\t * The inner HTML for the tag.\n\t\t *\n\t\t * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym\n\t\t * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}\n\t\t * if you prefer, but this one is recommended.\n\t\t */\n\n\t\t/**\n\t\t * @cfg {String} innerHTML\n\t\t *\n\t\t * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version\n\t\t * for acronym names.\n\t\t */\n\n\n\t\t/**\n\t\t * @protected\n\t\t * @property {RegExp} whitespaceRegex\n\t\t *\n\t\t * Regular expression used to match whitespace in a string of CSS classes.\n\t\t */\n\t\twhitespaceRegex : /\\s+/,\n\n\n\t\t/**\n\t\t * @constructor\n\t\t * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n\t\t */\n\t\tconstructor : function( cfg ) {\n\t\t\tAutolinker.Util.assign( this, cfg );\n\n\t\t\tthis.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym\n\t\t},\n\n\n\t\t/**\n\t\t * Sets the tag name that will be used to generate the tag with.\n\t\t *\n\t\t * @param {String} tagName\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\tsetTagName : function( tagName ) {\n\t\t\tthis.tagName = tagName;\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Retrieves the tag name.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetTagName : function() {\n\t\t\treturn this.tagName || \"\";\n\t\t},\n\n\n\t\t/**\n\t\t * Sets an attribute on the HtmlTag.\n\t\t *\n\t\t * @param {String} attrName The attribute name to set.\n\t\t * @param {String} attrValue The attribute value to set.\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\tsetAttr : function( attrName, attrValue ) {\n\t\t\tvar tagAttrs = this.getAttrs();\n\t\t\ttagAttrs[ attrName ] = attrValue;\n\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n\t\t *\n\t\t * @param {String} name The attribute name to retrieve.\n\t\t * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n\t\t */\n\t\tgetAttr : function( attrName ) {\n\t\t\treturn this.getAttrs()[ attrName ];\n\t\t},\n\n\n\t\t/**\n\t\t * Sets one or more attributes on the HtmlTag.\n\t\t *\n\t\t * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\tsetAttrs : function( attrs ) {\n\t\t\tvar tagAttrs = this.getAttrs();\n\t\t\tAutolinker.Util.assign( tagAttrs, attrs );\n\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Retrieves the attributes Object (map) for the HtmlTag.\n\t\t *\n\t\t * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n\t\t */\n\t\tgetAttrs : function() {\n\t\t\treturn this.attrs || ( this.attrs = {} );\n\t\t},\n\n\n\t\t/**\n\t\t * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n\t\t *\n\t\t * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\tsetClass : function( cssClass ) {\n\t\t\treturn this.setAttr( 'class', cssClass );\n\t\t},\n\n\n\t\t/**\n\t\t * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n\t\t *\n\t\t * @param {String} cssClass One or more space-separated CSS classes to add.\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\taddClass : function( cssClass ) {\n\t\t\tvar classAttr = this.getClass(),\n\t\t\t    whitespaceRegex = this.whitespaceRegex,\n\t\t\t    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n\t\t\t    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n\t\t\t    newClasses = cssClass.split( whitespaceRegex ),\n\t\t\t    newClass;\n\n\t\t\twhile( newClass = newClasses.shift() ) {\n\t\t\t\tif( indexOf( classes, newClass ) === -1 ) {\n\t\t\t\t\tclasses.push( newClass );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.getAttrs()[ 'class' ] = classes.join( \" \" );\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Convenience method to remove one or more CSS classes from the HtmlTag.\n\t\t *\n\t\t * @param {String} cssClass One or more space-separated CSS classes to remove.\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\tremoveClass : function( cssClass ) {\n\t\t\tvar classAttr = this.getClass(),\n\t\t\t    whitespaceRegex = this.whitespaceRegex,\n\t\t\t    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n\t\t\t    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n\t\t\t    removeClasses = cssClass.split( whitespaceRegex ),\n\t\t\t    removeClass;\n\n\t\t\twhile( classes.length && ( removeClass = removeClasses.shift() ) ) {\n\t\t\t\tvar idx = indexOf( classes, removeClass );\n\t\t\t\tif( idx !== -1 ) {\n\t\t\t\t\tclasses.splice( idx, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.getAttrs()[ 'class' ] = classes.join( \" \" );\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n\t\t * there are multiple.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetClass : function() {\n\t\t\treturn this.getAttrs()[ 'class' ] || \"\";\n\t\t},\n\n\n\t\t/**\n\t\t * Convenience method to check if the tag has a CSS class or not.\n\t\t *\n\t\t * @param {String} cssClass The CSS class to check for.\n\t\t * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n\t\t */\n\t\thasClass : function( cssClass ) {\n\t\t\treturn ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;\n\t\t},\n\n\n\t\t/**\n\t\t * Sets the inner HTML for the tag.\n\t\t *\n\t\t * @param {String} html The inner HTML to set.\n\t\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t\t */\n\t\tsetInnerHtml : function( html ) {\n\t\t\tthis.innerHtml = html;\n\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Retrieves the inner HTML for the tag.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetInnerHtml : function() {\n\t\t\treturn this.innerHtml || \"\";\n\t\t},\n\n\n\t\t/**\n\t\t * Override of superclass method used to generate the HTML string for the tag.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\ttoString : function() {\n\t\t\tvar tagName = this.getTagName(),\n\t\t\t    attrsStr = this.buildAttrsStr();\n\n\t\t\tattrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes\n\n\t\t\treturn [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( \"\" );\n\t\t},\n\n\n\t\t/**\n\t\t * Support method for {@link #toString}, returns the string space-separated key=\"value\" pairs, used to populate\n\t\t * the stringified HtmlTag.\n\t\t *\n\t\t * @protected\n\t\t * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n\t\t */\n\t\tbuildAttrsStr : function() {\n\t\t\tif( !this.attrs ) return \"\";  // no `attrs` Object (map) has been set, return empty string\n\n\t\t\tvar attrs = this.getAttrs(),\n\t\t\t    attrsArr = [];\n\n\t\t\tfor( var prop in attrs ) {\n\t\t\t\tif( attrs.hasOwnProperty( prop ) ) {\n\t\t\t\t\tattrsArr.push( prop + '=\"' + attrs[ prop ] + '\"' );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn attrsArr.join( \" \" );\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/*jshint scripturl:true */\n\t/**\n\t * @private\n\t * @class Autolinker.MatchValidator\n\t * @extends Object\n\t *\n\t * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.\n\t *\n\t * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),\n\t * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any\n\t * false positives that have been matched by the {@link Autolinker#matcherRegex}.\n\t */\n\tAutolinker.MatchValidator = Autolinker.Util.extend( Object, {\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} invalidProtocolRelMatchRegex\n\t\t *\n\t\t * The regular expression used to check a potential protocol-relative URL match, coming from the\n\t\t * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, \"//yahoo.com\"\n\t\t *\n\t\t * This regular expression checks to see if there is a word character before the '//' match in order to determine if\n\t\t * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in\n\t\t * JavaScript regular expressions.\n\t\t *\n\t\t * For instance, we want to autolink something like \"Go to: //google.com\", but we don't want to autolink something\n\t\t * like \"abc//google.com\"\n\t\t */\n\t\tinvalidProtocolRelMatchRegex : /^[\\w]\\/\\//,\n\n\t\t/**\n\t\t * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n\t\t *\n\t\t * @private\n\t\t * @property {RegExp} hasFullProtocolRegex\n\t\t */\n\t\thasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\\/\\//,\n\n\t\t/**\n\t\t * Regex to find the URI scheme, such as 'mailto:'.\n\t\t *\n\t\t * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n\t\t *\n\t\t * @private\n\t\t * @property {RegExp} uriSchemeRegex\n\t\t */\n\t\turiSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,\n\n\t\t/**\n\t\t * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n\t\t *\n\t\t * @private\n\t\t * @property {RegExp} hasWordCharAfterProtocolRegex\n\t\t */\n\t\thasWordCharAfterProtocolRegex : /:[^\\s]*?[A-Za-z]/,\n\n\n\t\t/**\n\t\t * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:\n\t\t *\n\t\t * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over\n\t\t *    matches like \"abc:def\"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n\t\t * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over\n\t\t *    matches like \"git:1.0\").\n\t\t * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character\n\t\t *    (effectively skipping over strings like \"abc//google.com\")\n\t\t *\n\t\t * Otherwise, returns `true`.\n\t\t *\n\t\t * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n\t\t * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n\t\t *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n\t\t * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n\t\t *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n\t\t *   preceding the '//'.\n\t\t * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or\n\t\t *   should just not be processed.\n\t\t */\n\t\tisValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {\n\t\t\tif(\n\t\t\t\t( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||\n\t\t\t\tthis.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n\t\t\t\tthis.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n\t\t\t\tthis.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like \"abc//google.com\")\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\n\t\t/**\n\t\t * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is\n\t\t * 'javascript:' or 'vbscript:'\n\t\t *\n\t\t * @private\n\t\t * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com'\n\t\t *   or 'mailto:a@a.com'.\n\t\t * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n\t\t */\n\t\tisValidUriScheme : function( uriSchemeMatch ) {\n\t\t\tvar uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();\n\n\t\t\treturn ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );\n\t\t},\n\n\n\t\t/**\n\t\t * Determines if a URL match does not have either:\n\t\t *\n\t\t * a) a full protocol (i.e. 'http://'), or\n\t\t * b) at least one dot ('.') in the domain name (for a non-full-protocol match).\n\t\t *\n\t\t * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot\n\t\t * in the domain name. If the match was 'git:abc.com', we would consider this valid.)\n\t\t *\n\t\t * @private\n\t\t * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n\t\t * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n\t\t *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n\t\t * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol\n\t\t *   match.\n\t\t */\n\t\turlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {\n\t\t\treturn ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );\n\t\t},\n\n\n\t\t/**\n\t\t * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).\n\t\t *\n\t\t * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something\n\t\t * like \"git:1.0\"\n\t\t *\n\t\t * @private\n\t\t * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n\t\t * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to\n\t\t *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol\n\t\t *   separator (':').\n\t\t * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`\n\t\t *   otherwise.\n\t\t */\n\t\turlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {\n\t\t\tif( urlMatch && protocolUrlMatch ) {\n\t\t\t\treturn !this.hasWordCharAfterProtocolRegex.test( urlMatch );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,\n\t\t * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in\n\t\t * order to be considered valid).\n\t\t *\n\t\t * @private\n\t\t * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n\t\t *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n\t\t *   preceding the '//'.\n\t\t * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.\n\t\t */\n\t\tisInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {\n\t\t\treturn ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/*jshint sub:true */\n\t/**\n\t * @protected\n\t * @class Autolinker.AnchorTagBuilder\n\t * @extends Object\n\t *\n\t * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.\n\t *\n\t * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may\n\t * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances\n\t * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:\n\t *\n\t *     var html = Autolinker.link( \"Test google.com\", {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n\t *             tag.setAttr( 'rel', 'nofollow' );\n\t *\n\t *             return tag;\n\t *         }\n\t *     } );\n\t *\n\t *     // generated html:\n\t *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n\t */\n\tAutolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {\n\n\t\t/**\n\t\t * @cfg {Boolean} newWindow\n\t\t * @inheritdoc Autolinker#newWindow\n\t\t */\n\n\t\t/**\n\t\t * @cfg {Number} truncate\n\t\t * @inheritdoc Autolinker#truncate\n\t\t */\n\n\t\t/**\n\t\t * @cfg {String} className\n\t\t * @inheritdoc Autolinker#className\n\t\t */\n\n\n\t\t/**\n\t\t * @constructor\n\t\t * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n\t\t */\n\t\tconstructor : function( cfg ) {\n\t\t\tAutolinker.Util.assign( this, cfg );\n\t\t},\n\n\n\t\t/**\n\t\t * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,\n\t\t * via its `match` object.\n\t\t *\n\t\t * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.\n\t\t * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n\t\t */\n\t\tbuild : function( match ) {\n\t\t\tvar tag = new Autolinker.HtmlTag( {\n\t\t\t\ttagName   : 'a',\n\t\t\t\tattrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),\n\t\t\t\tinnerHtml : this.processAnchorText( match.getAnchorText() )\n\t\t\t} );\n\n\t\t\treturn tag;\n\t\t},\n\n\n\t\t/**\n\t\t * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.\n\t\t *\n\t\t * @protected\n\t\t * @param {\"url\"/\"email\"/\"twitter\"} matchType The type of match that an anchor tag is being generated for.\n\t\t * @param {String} href The href for the anchor tag.\n\t\t * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n\t\t */\n\t\tcreateAttrs : function( matchType, anchorHref ) {\n\t\t\tvar attrs = {\n\t\t\t\t'href' : anchorHref  // we'll always have the `href` attribute\n\t\t\t};\n\n\t\t\tvar cssClass = this.createCssClass( matchType );\n\t\t\tif( cssClass ) {\n\t\t\t\tattrs[ 'class' ] = cssClass;\n\t\t\t}\n\t\t\tif( this.newWindow ) {\n\t\t\t\tattrs[ 'target' ] = \"_blank\";\n\t\t\t}\n\n\t\t\treturn attrs;\n\t\t},\n\n\n\t\t/**\n\t\t * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}\n\t\t * config.\n\t\t *\n\t\t * @private\n\t\t * @param {\"url\"/\"email\"/\"twitter\"} matchType The type of match that an anchor tag is being generated for.\n\t\t * @return {String} The CSS class string for the link. Example return: \"myLink myLink-url\". If no {@link #className}\n\t\t *   was configured, returns an empty string.\n\t\t */\n\t\tcreateCssClass : function( matchType ) {\n\t\t\tvar className = this.className;\n\n\t\t\tif( !className )\n\t\t\t\treturn \"\";\n\t\t\telse\n\t\t\t\treturn className + \" \" + className + \"-\" + matchType;  // ex: \"myLink myLink-url\", \"myLink myLink-email\", or \"myLink myLink-twitter\"\n\t\t},\n\n\n\t\t/**\n\t\t * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.\n\t\t *\n\t\t * @private\n\t\t * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).\n\t\t * @return {String} The processed `anchorText`.\n\t\t */\n\t\tprocessAnchorText : function( anchorText ) {\n\t\t\tanchorText = this.doTruncate( anchorText );\n\n\t\t\treturn anchorText;\n\t\t},\n\n\n\t\t/**\n\t\t * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.\n\t\t * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds \"..\" to the end.\n\t\t *\n\t\t * @private\n\t\t * @param {String} text The anchor tag's text (i.e. what will be displayed).\n\t\t * @return {String} The truncated anchor text.\n\t\t */\n\t\tdoTruncate : function( anchorText ) {\n\t\t\treturn Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/**\n\t * @abstract\n\t * @class Autolinker.match.Match\n\t *\n\t * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a\n\t * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.\n\t *\n\t * For example:\n\t *\n\t *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n\t *\n\t *     var linkedText = Autolinker.link( input, {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             console.log( \"href = \", match.getAnchorHref() );\n\t *             console.log( \"text = \", match.getAnchorText() );\n\t *\n\t *             switch( match.getType() ) {\n\t *                 case 'url' :\n\t *                     console.log( \"url: \", match.getUrl() );\n\t *\n\t *                 case 'email' :\n\t *                     console.log( \"email: \", match.getEmail() );\n\t *\n\t *                 case 'twitter' :\n\t *                     console.log( \"twitter: \", match.getTwitterHandle() );\n\t *             }\n\t *         }\n\t *     } );\n\t *\n\t * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.\n\t */\n\tAutolinker.match.Match = Autolinker.Util.extend( Object, {\n\n\t\t/**\n\t\t * @cfg {String} matchedText (required)\n\t\t *\n\t\t * The original text that was matched.\n\t\t */\n\n\n\t\t/**\n\t\t * @constructor\n\t\t * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n\t\t */\n\t\tconstructor : function( cfg ) {\n\t\t\tAutolinker.Util.assign( this, cfg );\n\t\t},\n\n\n\t\t/**\n\t\t * Returns a string name for the type of match that this class represents.\n\t\t *\n\t\t * @abstract\n\t\t * @return {String}\n\t\t */\n\t\tgetType : Autolinker.Util.abstractMethod,\n\n\n\t\t/**\n\t\t * Returns the original text that was matched.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetMatchedText : function() {\n\t\t\treturn this.matchedText;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor href that should be generated for the match.\n\t\t *\n\t\t * @abstract\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorHref : Autolinker.Util.abstractMethod,\n\n\n\t\t/**\n\t\t * Returns the anchor text that should be generated for the match.\n\t\t *\n\t\t * @abstract\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorText : Autolinker.Util.abstractMethod\n\n\t} );\n\t/*global Autolinker */\n\t/**\n\t * @class Autolinker.match.Email\n\t * @extends Autolinker.match.Match\n\t *\n\t * Represents a Email match found in an input string which should be Autolinked.\n\t *\n\t * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n\t */\n\tAutolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t\t/**\n\t\t * @cfg {String} email (required)\n\t\t *\n\t\t * The email address that was matched.\n\t\t */\n\n\n\t\t/**\n\t\t * Returns a string name for the type of match that this class represents.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetType : function() {\n\t\t\treturn 'email';\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the email address that was matched.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetEmail : function() {\n\t\t\treturn this.email;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor href that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorHref : function() {\n\t\t\treturn 'mailto:' + this.email;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor text that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorText : function() {\n\t\t\treturn this.email;\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/**\n\t * @class Autolinker.match.Twitter\n\t * @extends Autolinker.match.Match\n\t *\n\t * Represents a Twitter match found in an input string which should be Autolinked.\n\t *\n\t * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n\t */\n\tAutolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t\t/**\n\t\t * @cfg {String} twitterHandle (required)\n\t\t *\n\t\t * The Twitter handle that was matched.\n\t\t */\n\n\n\t\t/**\n\t\t * Returns the type of match that this class represents.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetType : function() {\n\t\t\treturn 'twitter';\n\t\t},\n\n\n\t\t/**\n\t\t * Returns a string name for the type of match that this class represents.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetTwitterHandle : function() {\n\t\t\treturn this.twitterHandle;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor href that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorHref : function() {\n\t\t\treturn 'https://twitter.com/' + this.twitterHandle;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor text that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorText : function() {\n\t\t\treturn '@' + this.twitterHandle;\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/**\n\t * @class Autolinker.match.Url\n\t * @extends Autolinker.match.Match\n\t *\n\t * Represents a Url match found in an input string which should be Autolinked.\n\t *\n\t * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n\t */\n\tAutolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t\t/**\n\t\t * @cfg {String} url (required)\n\t\t *\n\t\t * The url that was matched.\n\t\t */\n\n\t\t/**\n\t\t * @cfg {Boolean} protocolUrlMatch (required)\n\t\t *\n\t\t * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or\n\t\t * known TLD match.\n\t\t */\n\n\t\t/**\n\t\t * @cfg {Boolean} protocolRelativeMatch (required)\n\t\t *\n\t\t * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',\n\t\t * and will be either http:// or https:// based on the protocol that the site is loaded under.\n\t\t */\n\n\t\t/**\n\t\t * @cfg {Boolean} stripPrefix (required)\n\t\t * @inheritdoc Autolinker#stripPrefix\n\t\t */\n\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} urlPrefixRegex\n\t\t *\n\t\t * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.\n\t\t */\n\t\turlPrefixRegex: /^(https?:\\/\\/)?(www\\.)?/i,\n\n\t\t/**\n\t\t * @private\n\t\t * @property {RegExp} protocolRelativeRegex\n\t\t *\n\t\t * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n\t\t * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n\t\t */\n\t\tprotocolRelativeRegex : /^\\/\\//,\n\n\t\t/**\n\t\t * @private\n\t\t * @property {Boolean} protocolPrepended\n\t\t *\n\t\t * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n\t\t * {@link #url} did not have a protocol)\n\t\t */\n\t\tprotocolPrepended : false,\n\n\n\t\t/**\n\t\t * Returns a string name for the type of match that this class represents.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetType : function() {\n\t\t\treturn 'url';\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n\t\t * match was missing a protocol.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetUrl : function() {\n\t\t\tvar url = this.url;\n\n\t\t\t// if the url string doesn't begin with a protocol, assume 'http://'\n\t\t\tif( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {\n\t\t\t\turl = this.url = 'http://' + url;\n\n\t\t\t\tthis.protocolPrepended = true;\n\t\t\t}\n\n\t\t\treturn url;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor href that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorHref : function() {\n\t\t\tvar url = this.getUrl();\n\n\t\t\treturn url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor text that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorText : function() {\n\t\t\tvar anchorText = this.getUrl();\n\n\t\t\tif( this.protocolRelativeMatch ) {\n\t\t\t\t// Strip off any protocol-relative '//' from the anchor text\n\t\t\t\tanchorText = this.stripProtocolRelativePrefix( anchorText );\n\t\t\t}\n\t\t\tif( this.stripPrefix ) {\n\t\t\t\tanchorText = this.stripUrlPrefix( anchorText );\n\t\t\t}\n\t\t\tanchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one\n\n\t\t\treturn anchorText;\n\t\t},\n\n\n\t\t// ---------------------------------------\n\n\t\t// Utility Functionality\n\n\t\t/**\n\t\t * Strips the URL prefix (such as \"http://\" or \"https://\") from the given text.\n\t\t *\n\t\t * @private\n\t\t * @param {String} text The text of the anchor that is being generated, for which to strip off the\n\t\t *   url prefix (such as stripping off \"http://\")\n\t\t * @return {String} The `anchorText`, with the prefix stripped.\n\t\t */\n\t\tstripUrlPrefix : function( text ) {\n\t\t\treturn text.replace( this.urlPrefixRegex, '' );\n\t\t},\n\n\n\t\t/**\n\t\t * Strips any protocol-relative '//' from the anchor text.\n\t\t *\n\t\t * @private\n\t\t * @param {String} text The text of the anchor that is being generated, for which to strip off the\n\t\t *   protocol-relative prefix (such as stripping off \"//\")\n\t\t * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n\t\t */\n\t\tstripProtocolRelativePrefix : function( text ) {\n\t\t\treturn text.replace( this.protocolRelativeRegex, '' );\n\t\t},\n\n\n\t\t/**\n\t\t * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n\t\t *\n\t\t * @private\n\t\t * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n\t\t *   slash ('/') that may exist.\n\t\t * @return {String} The `anchorText`, with the trailing slash removed.\n\t\t */\n\t\tremoveTrailingSlash : function( anchorText ) {\n\t\t\tif( anchorText.charAt( anchorText.length - 1 ) === '/' ) {\n\t\t\t\tanchorText = anchorText.slice( 0, -1 );\n\t\t\t}\n\t\t\treturn anchorText;\n\t\t}\n\n\t} );\n\t/*global Autolinker */\n\t/**\n\t * @class Autolinker.match.Phone\n\t * @extends Autolinker.match.Match\n\t *\n\t * Represents a Phone match found in an input string which should be Autolinked.\n\t *\n\t * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n\t */\n\tAutolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t\t/**\n\t\t * Returns the type of match that this class represents.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetType : function() {\n\t\t\treturn 'phone';\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor href that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorHref : function() {\n\t\t\treturn 'tel:' + this.phone;\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the anchor text that should be generated for the match.\n\t\t *\n\t\t * @return {String}\n\t\t */\n\t\tgetAnchorText : function() {\n\t\t\treturn this.phone;\n\t\t}\n\n\t} );\n"]}